
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _top_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "top"
  pass


@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AbsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AdaptiveAvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.AdaptiveAvgPool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["output_size"] = (output_size if (
    issubclass(type(output_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_size, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AddConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.AddConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["const_val"])

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, coeff=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArangeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Arange"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, start, end, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(start))
    operands.append(_get_op_result_or_value(end))
    operands.append(_get_op_result_or_value(step))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArgOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Arg"

  _ODS_REGIONS = (0, True)

  def __init__(self, indices, values, input, axis, keepdims, mode, *, select_last_index=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArgModeAttr')) else
      _ods_ir.AttrBuilder.get('ArgModeAttr')(mode, context=_ods_context))
    if select_last_index is not None: attributes["select_last_index"] = (select_last_index if (
        issubclass(type(select_last_index), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(select_last_index, context=_ods_context))
    results.append(indices)
    results.append(values)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def keepdims(self):
    return _ods_ir.BoolAttr(self.operation.attributes["keepdims"])

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def select_last_index(self):
    return _ods_ir.BoolAttr(self.operation.attributes["select_last_index"])

  @select_last_index.setter
  def select_last_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["select_last_index"] = value

  @builtins.property
  def indices(self):
    return self.operation.results[0]

  @builtins.property
  def values(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, keys, values, queries_weight, queries_bias, keys_weight, keys_bias, values_weight, values_bias, out_weight, out_bias, musk, scale, head, *, has_bias=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(keys))
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(queries_weight))
    operands.append(_get_op_result_or_value(queries_bias))
    operands.append(_get_op_result_or_value(keys_weight))
    operands.append(_get_op_result_or_value(keys_bias))
    operands.append(_get_op_result_or_value(values_weight))
    operands.append(_get_op_result_or_value(values_bias))
    operands.append(_get_op_result_or_value(out_weight))
    operands.append(_get_op_result_or_value(out_bias))
    operands.append(_get_op_result_or_value(musk))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    attributes["head"] = (head if (
    issubclass(type(head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(head, context=_ods_context))
    if has_bias is not None: attributes["has_bias"] = (has_bias if (
        issubclass(type(has_bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(has_bias, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def keys(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def queries_weight(self):
    return self.operation.operands[3]

  @builtins.property
  def queries_bias(self):
    return self.operation.operands[4]

  @builtins.property
  def keys_weight(self):
    return self.operation.operands[5]

  @builtins.property
  def keys_bias(self):
    return self.operation.operands[6]

  @builtins.property
  def values_weight(self):
    return self.operation.operands[7]

  @builtins.property
  def values_bias(self):
    return self.operation.operands[8]

  @builtins.property
  def out_weight(self):
    return self.operation.operands[9]

  @builtins.property
  def out_bias(self):
    return self.operation.operands[10]

  @builtins.property
  def musk(self):
    return self.operation.operands[11]

  @builtins.property
  def scale(self):
    return _ods_ir.FloatAttr(self.operation.attributes["scale"])

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def head(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["head"])

  @head.setter
  def head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["head"] = value

  @builtins.property
  def has_bias(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["has_bias"])

  @has_bias.setter
  def has_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["has_bias"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.AvgPool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel_shape, strides, pads, *, ceil_mode=None, keepdims=None, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["ceil_mode"])

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def keepdims(self):
    return _ods_ir.BoolAttr(self.operation.attributes["keepdims"])

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def pad_value(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["pad_value"])

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return _ods_ir.BoolAttr(self.operation.attributes["count_include_pad"])

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BatchNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.BatchNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mean, variance, gamma, beta, *, epsilon=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(variance))
    operands.append(_get_op_result_or_value(gamma))
    operands.append(_get_op_result_or_value(beta))
    _ods_context = _ods_get_default_loc_context(loc)
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mean(self):
    return self.operation.operands[1]

  @builtins.property
  def variance(self):
    return self.operation.operands[2]

  @builtins.property
  def gamma(self):
    return self.operation.operands[3]

  @builtins.property
  def beta(self):
    return self.operation.operands[4]

  @builtins.property
  def epsilon(self):
    return _ods_ir.FloatAttr(self.operation.attributes["epsilon"])

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ClipOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Clip"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, min, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min"] = (min if (
    issubclass(type(min), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(min, context=_ods_context))
    attributes["max"] = (max if (
    issubclass(type(max), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(max, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return _ods_ir.FloatAttr(self.operation.attributes["min"])

  @min.setter
  def min(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min"] = value

  @builtins.property
  def max(self):
    return _ods_ir.FloatAttr(self.operation.attributes["max"])

  @max.setter
  def max(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CompareConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.CompareConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mode, const_val, inversed, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CompareModeAttr')) else
      _ods_ir.AttrBuilder.get('CompareModeAttr')(mode, context=_ods_context))
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    attributes["inversed"] = (inversed if (
    issubclass(type(inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inversed, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["const_val"])

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def inversed(self):
    return _ods_ir.BoolAttr(self.operation.attributes["inversed"])

  @inversed.setter
  def inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inversed"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CompareOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CompareModeAttr')) else
      _ods_ir.AttrBuilder.get('CompareModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, axis=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConstantFillOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ConstantFill"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    issubclass(type(value), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(value, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return _ods_ir.FloatAttr(self.operation.attributes["value"])

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, *, group=None, dilations=None, inserts=None, do_relu=None, relu_limit=None, in_int4_scale=None, in_int4_zp=None, out_int8_scale=None, out_int8_zp=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if inserts is not None: attributes["inserts"] = (inserts if (
        issubclass(type(inserts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(inserts, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if in_int4_scale is not None: attributes["in_int4_scale"] = (in_int4_scale if (
        issubclass(type(in_int4_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_scale, context=_ods_context))
    if in_int4_zp is not None: attributes["in_int4_zp"] = (in_int4_zp if (
        issubclass(type(in_int4_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_zp, context=_ods_context))
    if out_int8_scale is not None: attributes["out_int8_scale"] = (out_int8_scale if (
        issubclass(type(out_int8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_scale, context=_ods_context))
    if out_int8_zp is not None: attributes["out_int8_zp"] = (out_int8_zp if (
        issubclass(type(out_int8_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_zp, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def group(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["group"])

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def in_int4_scale(self):
    if "in_int4_scale" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["in_int4_scale"])

  @in_int4_scale.setter
  def in_int4_scale(self, value):
    if value is not None:
      self.operation.attributes["in_int4_scale"] = value
    elif "in_int4_scale" in self.operation.attributes:
      del self.operation.attributes["in_int4_scale"]

  @in_int4_scale.deleter
  def in_int4_scale(self):
    del self.operation.attributes["in_int4_scale"]

  @builtins.property
  def in_int4_zp(self):
    if "in_int4_zp" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["in_int4_zp"])

  @in_int4_zp.setter
  def in_int4_zp(self, value):
    if value is not None:
      self.operation.attributes["in_int4_zp"] = value
    elif "in_int4_zp" in self.operation.attributes:
      del self.operation.attributes["in_int4_zp"]

  @in_int4_zp.deleter
  def in_int4_zp(self):
    del self.operation.attributes["in_int4_zp"]

  @builtins.property
  def out_int8_scale(self):
    if "out_int8_scale" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["out_int8_scale"])

  @out_int8_scale.setter
  def out_int8_scale(self, value):
    if value is not None:
      self.operation.attributes["out_int8_scale"] = value
    elif "out_int8_scale" in self.operation.attributes:
      del self.operation.attributes["out_int8_scale"]

  @out_int8_scale.deleter
  def out_int8_scale(self):
    del self.operation.attributes["out_int8_scale"]

  @builtins.property
  def out_int8_zp(self):
    if "out_int8_zp" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["out_int8_zp"])

  @out_int8_zp.setter
  def out_int8_zp(self, value):
    if value is not None:
      self.operation.attributes["out_int8_zp"] = value
    elif "out_int8_zp" in self.operation.attributes:
      del self.operation.attributes["out_int8_zp"]

  @out_int8_zp.deleter
  def out_int8_zp(self):
    del self.operation.attributes["out_int8_zp"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CopyOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, input_stride, output_stride, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    issubclass(type(shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    attributes["input_stride"] = (input_stride if (
    issubclass(type(input_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_stride, context=_ods_context))
    attributes["output_stride"] = (output_stride if (
    issubclass(type(output_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_stride, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CosOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CoshOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CscOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Csc"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, pixel_format, aligned, y_align, w_align, channel_align, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pixel_format"] = (pixel_format if (
    issubclass(type(pixel_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(pixel_format, context=_ods_context))
    attributes["aligned"] = (aligned if (
    issubclass(type(aligned), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    attributes["y_align"] = (y_align if (
    issubclass(type(y_align), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(y_align, context=_ods_context))
    attributes["w_align"] = (w_align if (
    issubclass(type(w_align), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(w_align, context=_ods_context))
    attributes["channel_align"] = (channel_align if (
    issubclass(type(channel_align), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(channel_align, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def pixel_format(self):
    return _ods_ir.StringAttr(self.operation.attributes["pixel_format"])

  @pixel_format.setter
  def pixel_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pixel_format"] = value

  @builtins.property
  def aligned(self):
    return _ods_ir.BoolAttr(self.operation.attributes["aligned"])

  @aligned.setter
  def aligned(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def y_align(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["y_align"])

  @y_align.setter
  def y_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_align"] = value

  @builtins.property
  def w_align(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["w_align"])

  @w_align.setter
  def w_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["w_align"] = value

  @builtins.property
  def channel_align(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["channel_align"])

  @channel_align.setter
  def channel_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_align"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DeconvOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Deconv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, *, group=None, dilations=None, output_padding=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if output_padding is not None: attributes["output_padding"] = (output_padding if (
        issubclass(type(output_padding), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_padding, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def group(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["group"])

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DeformConv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DeformConv2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, offset, mask, bias, kernel_shape, strides, pads, *, group=None, deform_group=None, use_mask=None, dilations=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(offset))
    operands.append(_get_op_result_or_value(mask))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if deform_group is not None: attributes["deform_group"] = (deform_group if (
        issubclass(type(deform_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(deform_group, context=_ods_context))
    if use_mask is not None: attributes["use_mask"] = (use_mask if (
        issubclass(type(use_mask), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_mask, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def mask(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return self.operation.operands[4]

  @builtins.property
  def group(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["group"])

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def deform_group(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["deform_group"])

  @deform_group.setter
  def deform_group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["deform_group"] = value

  @builtins.property
  def use_mask(self):
    return _ods_ir.BoolAttr(self.operation.attributes["use_mask"])

  @use_mask.setter
  def use_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_mask"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Depth2SpaceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Depth2Space"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, block_h, block_w, is_CRD, is_inversed, *, in_is_NCHW=None, out_is_NCHW=None, swap_cr=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_h"] = (block_h if (
    issubclass(type(block_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_h, context=_ods_context))
    attributes["block_w"] = (block_w if (
    issubclass(type(block_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_w, context=_ods_context))
    attributes["is_CRD"] = (is_CRD if (
    issubclass(type(is_CRD), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_CRD, context=_ods_context))
    attributes["is_inversed"] = (is_inversed if (
    issubclass(type(is_inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_inversed, context=_ods_context))
    if in_is_NCHW is not None: attributes["in_is_NCHW"] = (in_is_NCHW if (
        issubclass(type(in_is_NCHW), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(in_is_NCHW, context=_ods_context))
    if out_is_NCHW is not None: attributes["out_is_NCHW"] = (out_is_NCHW if (
        issubclass(type(out_is_NCHW), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(out_is_NCHW, context=_ods_context))
    if swap_cr is not None: attributes["swap_cr"] = (swap_cr if (
        issubclass(type(swap_cr), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(swap_cr, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def block_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["block_h"])

  @block_h.setter
  def block_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_h"] = value

  @builtins.property
  def block_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["block_w"])

  @block_w.setter
  def block_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_w"] = value

  @builtins.property
  def is_CRD(self):
    return _ods_ir.BoolAttr(self.operation.attributes["is_CRD"])

  @is_CRD.setter
  def is_CRD(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_CRD"] = value

  @builtins.property
  def is_inversed(self):
    return _ods_ir.BoolAttr(self.operation.attributes["is_inversed"])

  @is_inversed.setter
  def is_inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_inversed"] = value

  @builtins.property
  def in_is_NCHW(self):
    return _ods_ir.BoolAttr(self.operation.attributes["in_is_NCHW"])

  @in_is_NCHW.setter
  def in_is_NCHW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["in_is_NCHW"] = value

  @builtins.property
  def out_is_NCHW(self):
    return _ods_ir.BoolAttr(self.operation.attributes["out_is_NCHW"])

  @out_is_NCHW.setter
  def out_is_NCHW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["out_is_NCHW"] = value

  @builtins.property
  def swap_cr(self):
    return _ods_ir.BoolAttr(self.operation.attributes["swap_cr"])

  @swap_cr.setter
  def swap_cr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["swap_cr"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DequantizeLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DequantizeLinear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, x_scale, x_zero_point, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["x_scale"] = (x_scale if (
    issubclass(type(x_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(x_scale, context=_ods_context))
    attributes["x_zero_point"] = (x_zero_point if (
    issubclass(type(x_zero_point), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(x_zero_point, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DetectionOutputOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DetectionOutput"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, num_classes, nms_threshold, top_k, code_type, keep_top_k, confidence_threshold, *, background_label_id=None, share_location=None, variance_encoded_in_target=None, eta=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_classes"] = (num_classes if (
    issubclass(type(num_classes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_classes, context=_ods_context))
    if background_label_id is not None: attributes["background_label_id"] = (background_label_id if (
        issubclass(type(background_label_id), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(background_label_id, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["top_k"] = (top_k if (
    issubclass(type(top_k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(top_k, context=_ods_context))
    attributes["code_type"] = (code_type if (
    issubclass(type(code_type), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DetectionOutputCodeTypeAttr')) else
      _ods_ir.AttrBuilder.get('DetectionOutputCodeTypeAttr')(code_type, context=_ods_context))
    attributes["keep_top_k"] = (keep_top_k if (
    issubclass(type(keep_top_k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_top_k, context=_ods_context))
    attributes["confidence_threshold"] = (confidence_threshold if (
    issubclass(type(confidence_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(confidence_threshold, context=_ods_context))
    if share_location is not None: attributes["share_location"] = (share_location if (
        issubclass(type(share_location), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(share_location, context=_ods_context))
    if variance_encoded_in_target is not None: attributes["variance_encoded_in_target"] = (variance_encoded_in_target if (
        issubclass(type(variance_encoded_in_target), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(variance_encoded_in_target, context=_ods_context))
    if eta is not None: attributes["eta"] = (eta if (
        issubclass(type(eta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(eta, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def num_classes(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num_classes"])

  @num_classes.setter
  def num_classes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_classes"] = value

  @builtins.property
  def background_label_id(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["background_label_id"])

  @background_label_id.setter
  def background_label_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["background_label_id"] = value

  @builtins.property
  def nms_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["nms_threshold"])

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def top_k(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["top_k"])

  @top_k.setter
  def top_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["top_k"] = value

  @builtins.property
  def code_type(self):
    return _ods_ir.StringAttr(self.operation.attributes["code_type"])

  @code_type.setter
  def code_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["code_type"] = value

  @builtins.property
  def keep_top_k(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["keep_top_k"])

  @keep_top_k.setter
  def keep_top_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_top_k"] = value

  @builtins.property
  def confidence_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["confidence_threshold"])

  @confidence_threshold.setter
  def confidence_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["confidence_threshold"] = value

  @builtins.property
  def share_location(self):
    return _ods_ir.BoolAttr(self.operation.attributes["share_location"])

  @share_location.setter
  def share_location(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["share_location"] = value

  @builtins.property
  def variance_encoded_in_target(self):
    return _ods_ir.FloatAttr(self.operation.attributes["variance_encoded_in_target"])

  @variance_encoded_in_target.setter
  def variance_encoded_in_target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variance_encoded_in_target"] = value

  @builtins.property
  def eta(self):
    return _ods_ir.FloatAttr(self.operation.attributes["eta"])

  @eta.setter
  def eta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eta"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Div"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, is_reverse=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return _ods_ir.BoolAttr(self.operation.attributes["is_reverse"])

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Elu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    issubclass(type(alpha), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return _ods_ir.FloatAttr(self.operation.attributes["alpha"])

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ErfOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FlattenOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Flatten"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, start_dim=None, end_dim=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if start_dim is not None: attributes["start_dim"] = (start_dim if (
        issubclass(type(start_dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(start_dim, context=_ods_context))
    if end_dim is not None: attributes["end_dim"] = (end_dim if (
        issubclass(type(end_dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(end_dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start_dim(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["start_dim"])

  @start_dim.setter
  def start_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["start_dim"] = value

  @builtins.property
  def end_dim(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["end_dim"])

  @end_dim.setter
  def end_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end_dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FrcnDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.FrcnDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, class_num, obj_threshold, nms_threshold, keep_topk, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["class_num"] = (class_num if (
    issubclass(type(class_num), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(class_num, context=_ods_context))
    attributes["obj_threshold"] = (obj_threshold if (
    issubclass(type(obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(obj_threshold, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def class_num(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["class_num"])

  @class_num.setter
  def class_num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["class_num"] = value

  @builtins.property
  def obj_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["obj_threshold"])

  @obj_threshold.setter
  def obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["obj_threshold"] = value

  @builtins.property
  def nms_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["nms_threshold"])

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["keep_topk"])

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GELUOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GELU"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GRUOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GRU"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, Y_h, input, filter, recurrence, bias, initial_h, hidden_size, bidirectional, *, linear_before_reset=None, batch_first=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(recurrence))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(initial_h))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hidden_size"] = (hidden_size if (
    issubclass(type(hidden_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hidden_size, context=_ods_context))
    attributes["bidirectional"] = (bidirectional if (
    issubclass(type(bidirectional), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(bidirectional, context=_ods_context))
    if linear_before_reset is not None: attributes["linear_before_reset"] = (linear_before_reset if (
        issubclass(type(linear_before_reset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(linear_before_reset, context=_ods_context))
    if batch_first is not None: attributes["batch_first"] = (batch_first if (
        issubclass(type(batch_first), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(batch_first, context=_ods_context))
    results.append(Y)
    results.append(Y_h)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def recurrence(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def initial_h(self):
    return self.operation.operands[4]

  @builtins.property
  def hidden_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["hidden_size"])

  @hidden_size.setter
  def hidden_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hidden_size"] = value

  @builtins.property
  def bidirectional(self):
    return _ods_ir.BoolAttr(self.operation.attributes["bidirectional"])

  @bidirectional.setter
  def bidirectional(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bidirectional"] = value

  @builtins.property
  def linear_before_reset(self):
    return _ods_ir.BoolAttr(self.operation.attributes["linear_before_reset"])

  @linear_before_reset.setter
  def linear_before_reset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["linear_before_reset"] = value

  @builtins.property
  def batch_first(self):
    return _ods_ir.BoolAttr(self.operation.attributes["batch_first"])

  @batch_first.setter
  def batch_first(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_first"] = value

  @builtins.property
  def Y(self):
    return self.operation.results[0]

  @builtins.property
  def Y_h(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GatherElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherNDOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GatherND"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, *, batch_dims=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if batch_dims is not None: attributes["batch_dims"] = (batch_dims if (
        issubclass(type(batch_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(batch_dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def batch_dims(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["batch_dims"])

  @batch_dims.setter
  def batch_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GridSamplerOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GridSampler"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, grid, mode, padding_mode, align_corners, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(grid))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mode, context=_ods_context))
    attributes["padding_mode"] = (padding_mode if (
    issubclass(type(padding_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_mode, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def grid(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def padding_mode(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["padding_mode"])

  @padding_mode.setter
  def padding_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_mode"] = value

  @builtins.property
  def align_corners(self):
    return _ods_ir.BoolAttr(self.operation.attributes["align_corners"])

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GroupNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, num_groups, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_groups"] = (num_groups if (
    issubclass(type(num_groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def num_groups(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num_groups"])

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def eps(self):
    return _ods_ir.FloatAttr(self.operation.attributes["eps"])

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HardSigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "top.HardSigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, beta, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    issubclass(type(alpha), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    attributes["beta"] = (beta if (
    issubclass(type(beta), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return _ods_ir.FloatAttr(self.operation.attributes["alpha"])

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def beta(self):
    return _ods_ir.FloatAttr(self.operation.attributes["beta"])

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HardSwishOp(_ods_ir.OpView):
  OPERATION_NAME = "top.HardSwish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "top.If"

  _ODS_REGIONS = (2, True)

  def __init__(self, output, cond, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def then_branch(self):
    return self.regions[0]

  @builtins.property
  def else_branch(self):
    return self.regions[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InputOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Input"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, pixel_format=None, channel_format=None, resize_dims=None, keep_aspect_ratio=None, pad_value=None, pad_type=None, scale=None, mean=None, customization_format=None, aligned=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if pixel_format is not None: attributes["pixel_format"] = (pixel_format if (
        issubclass(type(pixel_format), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('PixelFormatAttr')) else
          _ods_ir.AttrBuilder.get('PixelFormatAttr')(pixel_format, context=_ods_context))
    if channel_format is not None: attributes["channel_format"] = (channel_format if (
        issubclass(type(channel_format), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ChannelFormatAttr')) else
          _ods_ir.AttrBuilder.get('ChannelFormatAttr')(channel_format, context=_ods_context))
    if resize_dims is not None: attributes["resize_dims"] = (resize_dims if (
        issubclass(type(resize_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    if keep_aspect_ratio is not None: attributes["keep_aspect_ratio"] = (keep_aspect_ratio if (
        issubclass(type(keep_aspect_ratio), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_aspect_ratio, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if pad_type is not None: attributes["pad_type"] = (pad_type if (
        issubclass(type(pad_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('PadModeAttr')) else
          _ods_ir.AttrBuilder.get('PadModeAttr')(pad_type, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    if mean is not None: attributes["mean"] = (mean if (
        issubclass(type(mean), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    if customization_format is not None: attributes["customization_format"] = (customization_format if (
        issubclass(type(customization_format), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    if aligned is not None: attributes["aligned"] = (aligned if (
        issubclass(type(aligned), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def pixel_format(self):
    if "pixel_format" not in self.operation.attributes:
      return None
    return _ods_ir.StringAttr(self.operation.attributes["pixel_format"])

  @pixel_format.setter
  def pixel_format(self, value):
    if value is not None:
      self.operation.attributes["pixel_format"] = value
    elif "pixel_format" in self.operation.attributes:
      del self.operation.attributes["pixel_format"]

  @pixel_format.deleter
  def pixel_format(self):
    del self.operation.attributes["pixel_format"]

  @builtins.property
  def channel_format(self):
    if "channel_format" not in self.operation.attributes:
      return None
    return _ods_ir.StringAttr(self.operation.attributes["channel_format"])

  @channel_format.setter
  def channel_format(self, value):
    if value is not None:
      self.operation.attributes["channel_format"] = value
    elif "channel_format" in self.operation.attributes:
      del self.operation.attributes["channel_format"]

  @channel_format.deleter
  def channel_format(self):
    del self.operation.attributes["channel_format"]

  @builtins.property
  def keep_aspect_ratio(self):
    if "keep_aspect_ratio" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["keep_aspect_ratio"])

  @keep_aspect_ratio.setter
  def keep_aspect_ratio(self, value):
    if value is not None:
      self.operation.attributes["keep_aspect_ratio"] = value
    elif "keep_aspect_ratio" in self.operation.attributes:
      del self.operation.attributes["keep_aspect_ratio"]

  @keep_aspect_ratio.deleter
  def keep_aspect_ratio(self):
    del self.operation.attributes["keep_aspect_ratio"]

  @builtins.property
  def pad_value(self):
    if "pad_value" not in self.operation.attributes:
      return None
    return _ods_ir.IntegerAttr(self.operation.attributes["pad_value"])

  @pad_value.setter
  def pad_value(self, value):
    if value is not None:
      self.operation.attributes["pad_value"] = value
    elif "pad_value" in self.operation.attributes:
      del self.operation.attributes["pad_value"]

  @pad_value.deleter
  def pad_value(self):
    del self.operation.attributes["pad_value"]

  @builtins.property
  def pad_type(self):
    if "pad_type" not in self.operation.attributes:
      return None
    return _ods_ir.StringAttr(self.operation.attributes["pad_type"])

  @pad_type.setter
  def pad_type(self, value):
    if value is not None:
      self.operation.attributes["pad_type"] = value
    elif "pad_type" in self.operation.attributes:
      del self.operation.attributes["pad_type"]

  @pad_type.deleter
  def pad_type(self):
    del self.operation.attributes["pad_type"]

  @builtins.property
  def customization_format(self):
    if "customization_format" not in self.operation.attributes:
      return None
    return _ods_ir.StringAttr(self.operation.attributes["customization_format"])

  @customization_format.setter
  def customization_format(self, value):
    if value is not None:
      self.operation.attributes["customization_format"] = value
    elif "customization_format" in self.operation.attributes:
      del self.operation.attributes["customization_format"]

  @customization_format.deleter
  def customization_format(self):
    del self.operation.attributes["customization_format"]

  @builtins.property
  def aligned(self):
    if "aligned" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["aligned"])

  @aligned.setter
  def aligned(self, value):
    if value is not None:
      self.operation.attributes["aligned"] = value
    elif "aligned" in self.operation.attributes:
      del self.operation.attributes["aligned"]

  @aligned.deleter
  def aligned(self):
    del self.operation.attributes["aligned"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InstanceNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.InstanceNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def eps(self):
    return _ods_ir.FloatAttr(self.operation.attributes["eps"])

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InterpOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Interp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, target_shape, mode, coord_mode, *, scale_h=None, scale_w=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(target_shape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InterpModeAttr')) else
      _ods_ir.AttrBuilder.get('InterpModeAttr')(mode, context=_ods_context))
    attributes["coord_mode"] = (coord_mode if (
    issubclass(type(coord_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InterpCoordModeAttr')) else
      _ods_ir.AttrBuilder.get('InterpCoordModeAttr')(coord_mode, context=_ods_context))
    if scale_h is not None: attributes["scale_h"] = (scale_h if (
        issubclass(type(scale_h), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale_h, context=_ods_context))
    if scale_w is not None: attributes["scale_w"] = (scale_w if (
        issubclass(type(scale_w), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale_w, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def target_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def coord_mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["coord_mode"])

  @coord_mode.setter
  def coord_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coord_mode"] = value

  @builtins.property
  def scale_h(self):
    return _ods_ir.FloatAttr(self.operation.attributes["scale_h"])

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return _ods_ir.FloatAttr(self.operation.attributes["scale_w"])

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LRNOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LRN"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, size, *, alpha=None, beta=None, bias=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    issubclass(type(size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(size, context=_ods_context))
    if alpha is not None: attributes["alpha"] = (alpha if (
        issubclass(type(alpha), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if bias is not None: attributes["bias"] = (bias if (
        issubclass(type(bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(bias, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["size"])

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def alpha(self):
    return _ods_ir.FloatAttr(self.operation.attributes["alpha"])

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def beta(self):
    return _ods_ir.FloatAttr(self.operation.attributes["beta"])

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def bias(self):
    return _ods_ir.FloatAttr(self.operation.attributes["bias"])

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LSTMOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LSTM"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, Y_h, Y_c, input, filter, recurrence, bias, initial_h, initial_c, cont, hidden_size, bidirectional, *, batch_first=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(recurrence))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(initial_h))
    operands.append(_get_op_result_or_value(initial_c))
    operands.append(_get_op_result_or_value(cont))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hidden_size"] = (hidden_size if (
    issubclass(type(hidden_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hidden_size, context=_ods_context))
    attributes["bidirectional"] = (bidirectional if (
    issubclass(type(bidirectional), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(bidirectional, context=_ods_context))
    if batch_first is not None: attributes["batch_first"] = (batch_first if (
        issubclass(type(batch_first), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(batch_first, context=_ods_context))
    results.append(Y)
    results.append(Y_h)
    results.append(Y_c)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def recurrence(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def initial_h(self):
    return self.operation.operands[4]

  @builtins.property
  def initial_c(self):
    return self.operation.operands[5]

  @builtins.property
  def cont(self):
    return self.operation.operands[6]

  @builtins.property
  def hidden_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["hidden_size"])

  @hidden_size.setter
  def hidden_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hidden_size"] = value

  @builtins.property
  def bidirectional(self):
    return _ods_ir.BoolAttr(self.operation.attributes["bidirectional"])

  @bidirectional.setter
  def bidirectional(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bidirectional"] = value

  @builtins.property
  def batch_first(self):
    return _ods_ir.BoolAttr(self.operation.attributes["batch_first"])

  @batch_first.setter
  def batch_first(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_first"] = value

  @builtins.property
  def Y(self):
    return self.operation.results[0]

  @builtins.property
  def Y_h(self):
    return self.operation.results[1]

  @builtins.property
  def Y_c(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LayerNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean, rstd, input, weight, bias, normalized_shape, axis, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    results.append(mean)
    results.append(rstd)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def eps(self):
    return _ods_ir.FloatAttr(self.operation.attributes["eps"])

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean(self):
    return self.operation.results[1]

  @builtins.property
  def rstd(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LeakyReluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LeakyRelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    issubclass(type(alpha), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return _ods_ir.FloatAttr(self.operation.attributes["alpha"])

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ListOp(_ods_ir.OpView):
  OPERATION_NAME = "top.List"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Log"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, v_final_and_scan_outputs, M, cond, v_initial, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(M))
    operands.append(_get_op_result_or_value(cond))
    operands.extend(_get_op_results_or_values(v_initial))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(v_final_and_scan_outputs)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def M(self):
    return self.operation.operands[0]

  @builtins.property
  def cond(self):
    return self.operation.operands[1]

  @builtins.property
  def v_initial(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def v_final_and_scan_outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskedFillOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaskedFill"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cond, brn, inversed, const_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.append(_get_op_result_or_value(brn))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inversed"] = (inversed if (
    issubclass(type(inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inversed, context=_ods_context))
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def brn(self):
    return self.operation.operands[1]

  @builtins.property
  def inversed(self):
    return _ods_ir.BoolAttr(self.operation.attributes["inversed"])

  @inversed.setter
  def inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inversed"] = value

  @builtins.property
  def const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["const_val"])

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MatMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, right, bias, *, right_transpose=None, left_transpose=None, output_transpose=None, hdim_is_batch=None, keep_dims=None, do_relu=None, relu_limit=None, in_int4_scale=None, in_int4_zp=None, out_int8_scale=None, out_int8_zp=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(right))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if right_transpose is not None: attributes["right_transpose"] = (right_transpose if (
        issubclass(type(right_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(right_transpose, context=_ods_context))
    if left_transpose is not None: attributes["left_transpose"] = (left_transpose if (
        issubclass(type(left_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(left_transpose, context=_ods_context))
    if output_transpose is not None: attributes["output_transpose"] = (output_transpose if (
        issubclass(type(output_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(output_transpose, context=_ods_context))
    if hdim_is_batch is not None: attributes["hdim_is_batch"] = (hdim_is_batch if (
        issubclass(type(hdim_is_batch), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(hdim_is_batch, context=_ods_context))
    if keep_dims is not None: attributes["keep_dims"] = (keep_dims if (
        issubclass(type(keep_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_dims, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if in_int4_scale is not None: attributes["in_int4_scale"] = (in_int4_scale if (
        issubclass(type(in_int4_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_scale, context=_ods_context))
    if in_int4_zp is not None: attributes["in_int4_zp"] = (in_int4_zp if (
        issubclass(type(in_int4_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_zp, context=_ods_context))
    if out_int8_scale is not None: attributes["out_int8_scale"] = (out_int8_scale if (
        issubclass(type(out_int8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_scale, context=_ods_context))
    if out_int8_zp is not None: attributes["out_int8_zp"] = (out_int8_zp if (
        issubclass(type(out_int8_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_zp, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def right_transpose(self):
    return _ods_ir.BoolAttr(self.operation.attributes["right_transpose"])

  @right_transpose.setter
  def right_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_transpose"] = value

  @builtins.property
  def left_transpose(self):
    return _ods_ir.BoolAttr(self.operation.attributes["left_transpose"])

  @left_transpose.setter
  def left_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_transpose"] = value

  @builtins.property
  def output_transpose(self):
    return _ods_ir.BoolAttr(self.operation.attributes["output_transpose"])

  @output_transpose.setter
  def output_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_transpose"] = value

  @builtins.property
  def hdim_is_batch(self):
    return _ods_ir.BoolAttr(self.operation.attributes["hdim_is_batch"])

  @hdim_is_batch.setter
  def hdim_is_batch(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hdim_is_batch"] = value

  @builtins.property
  def keep_dims(self):
    return _ods_ir.BoolAttr(self.operation.attributes["keep_dims"])

  @keep_dims.setter
  def keep_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_dims"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def in_int4_scale(self):
    if "in_int4_scale" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["in_int4_scale"])

  @in_int4_scale.setter
  def in_int4_scale(self, value):
    if value is not None:
      self.operation.attributes["in_int4_scale"] = value
    elif "in_int4_scale" in self.operation.attributes:
      del self.operation.attributes["in_int4_scale"]

  @in_int4_scale.deleter
  def in_int4_scale(self):
    del self.operation.attributes["in_int4_scale"]

  @builtins.property
  def in_int4_zp(self):
    if "in_int4_zp" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["in_int4_zp"])

  @in_int4_zp.setter
  def in_int4_zp(self, value):
    if value is not None:
      self.operation.attributes["in_int4_zp"] = value
    elif "in_int4_zp" in self.operation.attributes:
      del self.operation.attributes["in_int4_zp"]

  @in_int4_zp.deleter
  def in_int4_zp(self):
    del self.operation.attributes["in_int4_zp"]

  @builtins.property
  def out_int8_scale(self):
    if "out_int8_scale" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["out_int8_scale"])

  @out_int8_scale.setter
  def out_int8_scale(self, value):
    if value is not None:
      self.operation.attributes["out_int8_scale"] = value
    elif "out_int8_scale" in self.operation.attributes:
      del self.operation.attributes["out_int8_scale"]

  @out_int8_scale.deleter
  def out_int8_scale(self):
    del self.operation.attributes["out_int8_scale"]

  @builtins.property
  def out_int8_zp(self):
    if "out_int8_zp" not in self.operation.attributes:
      return None
    return _ods_ir.FloatAttr(self.operation.attributes["out_int8_zp"])

  @out_int8_zp.setter
  def out_int8_zp(self, value):
    if value is not None:
      self.operation.attributes["out_int8_zp"] = value
    elif "out_int8_zp" in self.operation.attributes:
      del self.operation.attributes["out_int8_zp"]

  @out_int8_zp.deleter
  def out_int8_zp(self):
    del self.operation.attributes["out_int8_zp"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Max"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxPool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel_shape, strides, pads, *, ceil_mode=None, keepdims=None, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["ceil_mode"])

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def keepdims(self):
    return _ods_ir.BoolAttr(self.operation.attributes["keepdims"])

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def pad_value(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["pad_value"])

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return _ods_ir.BoolAttr(self.operation.attributes["count_include_pad"])

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolWithMaskOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxPoolWithMask"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mask, input, kernel_shape, strides, pads, *, ceil_mode=None, keepdims=None, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    results.append(mask)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["ceil_mode"])

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def keepdims(self):
    return _ods_ir.BoolAttr(self.operation.attributes["keepdims"])

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def pad_value(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["pad_value"])

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return _ods_ir.BoolAttr(self.operation.attributes["count_include_pad"])

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mask(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxUnpoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxUnpool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mask, scale_h, scale_w, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_w, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def scale_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["scale_h"])

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["scale_w"])

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MeshGridOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MeshGrid"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, is_reverse, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["is_reverse"] = (is_reverse if (
    issubclass(type(is_reverse), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return _ods_ir.BoolAttr(self.operation.attributes["is_reverse"])

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Min"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MishOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Mish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MulConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["const_val"])

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NmsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Nms"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, center_point_box, max_output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["center_point_box"] = (center_point_box if (
    issubclass(type(center_point_box), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(center_point_box, context=_ods_context))
    attributes["max_output_size"] = (max_output_size if (
    issubclass(type(max_output_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(max_output_size, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def center_point_box(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["center_point_box"])

  @center_point_box.setter
  def center_point_box(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["center_point_box"] = value

  @builtins.property
  def max_output_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["max_output_size"])

  @max_output_size.setter
  def max_output_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_output_size"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NonZeroOp(_ods_ir.OpView):
  OPERATION_NAME = "top.NonZero"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('NonZeroOrderAttr')) else
      _ods_ir.AttrBuilder.get('NonZeroOrderAttr')(order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def order(self):
    return _ods_ir.StringAttr(self.operation.attributes["order"])

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NoneOp(_ods_ir.OpView):
  OPERATION_NAME = "top.None"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NormalizeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Normalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, *, across_spatial=None, channel_shared=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(scale))
    _ods_context = _ods_get_default_loc_context(loc)
    if across_spatial is not None: attributes["across_spatial"] = (across_spatial if (
        issubclass(type(across_spatial), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(across_spatial, context=_ods_context))
    if channel_shared is not None: attributes["channel_shared"] = (channel_shared if (
        issubclass(type(channel_shared), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(channel_shared, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def across_spatial(self):
    return _ods_ir.BoolAttr(self.operation.attributes["across_spatial"])

  @across_spatial.setter
  def across_spatial(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["across_spatial"] = value

  @builtins.property
  def channel_shared(self):
    return _ods_ir.BoolAttr(self.operation.attributes["channel_shared"])

  @channel_shared.setter
  def channel_shared(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_shared"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PReluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PRelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, slope, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(slope))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def slope(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PackOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, axis, values_count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["values_count"] = (values_count if (
    issubclass(type(values_count), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(values_count, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def values_count(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["values_count"])

  @values_count.setter
  def values_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values_count"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, paddings, *, val=None, mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["paddings"] = (paddings if (
    issubclass(type(paddings), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(paddings, context=_ods_context))
    if val is not None: attributes["val"] = (val if (
        issubclass(type(val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(val, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        issubclass(type(mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["val"])

  @val.setter
  def val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["val"] = value

  @builtins.property
  def mode(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Permute"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PixelNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PixelNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def eps(self):
    return _ods_ir.FloatAttr(self.operation.attributes["eps"])

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PoolMaskOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PoolMask"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["scale"])

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, exponent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exponent"] = (exponent if (
    issubclass(type(exponent), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(exponent, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent(self):
    return _ods_ir.FloatAttr(self.operation.attributes["exponent"])

  @exponent.setter
  def exponent(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exponent"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PreprocessOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Preprocess"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant_mode, customization_format, channel_order, resize_dims, scale, mean, *, sign=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(quant_mode, context=_ods_context))
    attributes["customization_format"] = (customization_format if (
    issubclass(type(customization_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(channel_order, context=_ods_context))
    attributes["resize_dims"] = (resize_dims if (
    issubclass(type(resize_dims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["mean"] = (mean if (
    issubclass(type(mean), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["quant_mode"])

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def customization_format(self):
    return _ods_ir.StringAttr(self.operation.attributes["customization_format"])

  @customization_format.setter
  def customization_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["customization_format"] = value

  @builtins.property
  def channel_order(self):
    return _ods_ir.StringAttr(self.operation.attributes["channel_order"])

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def sign(self):
    return _ods_ir.BoolAttr(self.operation.attributes["sign"])

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PriorBoxOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PriorBox"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, min_size, max_size, aspect_ratios, variance, step_h, step_w, img_h, img_w, num_priors, *, clip=None, offset=None, use_default_aspect_ratio=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min_size"] = (min_size if (
    issubclass(type(min_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(min_size, context=_ods_context))
    attributes["max_size"] = (max_size if (
    issubclass(type(max_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(max_size, context=_ods_context))
    attributes["aspect_ratios"] = (aspect_ratios if (
    issubclass(type(aspect_ratios), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(aspect_ratios, context=_ods_context))
    attributes["variance"] = (variance if (
    issubclass(type(variance), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(variance, context=_ods_context))
    if clip is not None: attributes["clip"] = (clip if (
        issubclass(type(clip), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(clip, context=_ods_context))
    attributes["step_h"] = (step_h if (
    issubclass(type(step_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(step_h, context=_ods_context))
    attributes["step_w"] = (step_w if (
    issubclass(type(step_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(step_w, context=_ods_context))
    attributes["img_h"] = (img_h if (
    issubclass(type(img_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(img_h, context=_ods_context))
    attributes["img_w"] = (img_w if (
    issubclass(type(img_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(img_w, context=_ods_context))
    if offset is not None: attributes["offset"] = (offset if (
        issubclass(type(offset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(offset, context=_ods_context))
    attributes["num_priors"] = (num_priors if (
    issubclass(type(num_priors), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_priors, context=_ods_context))
    if use_default_aspect_ratio is not None: attributes["use_default_aspect_ratio"] = (use_default_aspect_ratio if (
        issubclass(type(use_default_aspect_ratio), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_default_aspect_ratio, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def clip(self):
    return _ods_ir.BoolAttr(self.operation.attributes["clip"])

  @clip.setter
  def clip(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clip"] = value

  @builtins.property
  def step_h(self):
    return _ods_ir.FloatAttr(self.operation.attributes["step_h"])

  @step_h.setter
  def step_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step_h"] = value

  @builtins.property
  def step_w(self):
    return _ods_ir.FloatAttr(self.operation.attributes["step_w"])

  @step_w.setter
  def step_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step_w"] = value

  @builtins.property
  def img_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["img_h"])

  @img_h.setter
  def img_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["img_h"] = value

  @builtins.property
  def img_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["img_w"])

  @img_w.setter
  def img_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["img_w"] = value

  @builtins.property
  def offset(self):
    return _ods_ir.FloatAttr(self.operation.attributes["offset"])

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def num_priors(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num_priors"])

  @num_priors.setter
  def num_priors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_priors"] = value

  @builtins.property
  def use_default_aspect_ratio(self):
    return _ods_ir.BoolAttr(self.operation.attributes["use_default_aspect_ratio"])

  @use_default_aspect_ratio.setter
  def use_default_aspect_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_default_aspect_ratio"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ProposalOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Proposal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, net_input_h, net_input_w, feat_stride, anchor_base_size, rpn_obj_threshold, rpn_nms_threshold, rpn_nms_post_top_n, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["net_input_h"] = (net_input_h if (
    issubclass(type(net_input_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_h, context=_ods_context))
    attributes["net_input_w"] = (net_input_w if (
    issubclass(type(net_input_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_w, context=_ods_context))
    attributes["feat_stride"] = (feat_stride if (
    issubclass(type(feat_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feat_stride, context=_ods_context))
    attributes["anchor_base_size"] = (anchor_base_size if (
    issubclass(type(anchor_base_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(anchor_base_size, context=_ods_context))
    attributes["rpn_obj_threshold"] = (rpn_obj_threshold if (
    issubclass(type(rpn_obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(rpn_obj_threshold, context=_ods_context))
    attributes["rpn_nms_threshold"] = (rpn_nms_threshold if (
    issubclass(type(rpn_nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(rpn_nms_threshold, context=_ods_context))
    attributes["rpn_nms_post_top_n"] = (rpn_nms_post_top_n if (
    issubclass(type(rpn_nms_post_top_n), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(rpn_nms_post_top_n, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def net_input_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["net_input_h"])

  @net_input_h.setter
  def net_input_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_h"] = value

  @builtins.property
  def net_input_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["net_input_w"])

  @net_input_w.setter
  def net_input_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_w"] = value

  @builtins.property
  def feat_stride(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["feat_stride"])

  @feat_stride.setter
  def feat_stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feat_stride"] = value

  @builtins.property
  def anchor_base_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["anchor_base_size"])

  @anchor_base_size.setter
  def anchor_base_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchor_base_size"] = value

  @builtins.property
  def rpn_obj_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["rpn_obj_threshold"])

  @rpn_obj_threshold.setter
  def rpn_obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rpn_obj_threshold"] = value

  @builtins.property
  def rpn_nms_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["rpn_nms_threshold"])

  @rpn_nms_threshold.setter
  def rpn_nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rpn_nms_threshold"] = value

  @builtins.property
  def rpn_nms_post_top_n(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["rpn_nms_post_top_n"])

  @rpn_nms_post_top_n.setter
  def rpn_nms_post_top_n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rpn_nms_post_top_n"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class QuantizeLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "top.QuantizeLinear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, y_scale, y_zero_point, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["y_scale"] = (y_scale if (
    issubclass(type(y_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(y_scale, context=_ods_context))
    attributes["y_zero_point"] = (y_zero_point if (
    issubclass(type(y_zero_point), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(y_zero_point, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ROIPoolingOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ROIPooling"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, pooled_h, pooled_w, spatial_scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pooled_h"] = (pooled_h if (
    issubclass(type(pooled_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(pooled_h, context=_ods_context))
    attributes["pooled_w"] = (pooled_w if (
    issubclass(type(pooled_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(pooled_w, context=_ods_context))
    attributes["spatial_scale"] = (spatial_scale if (
    issubclass(type(spatial_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(spatial_scale, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def pooled_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["pooled_h"])

  @pooled_h.setter
  def pooled_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pooled_h"] = value

  @builtins.property
  def pooled_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["pooled_w"])

  @pooled_w.setter
  def pooled_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pooled_w"] = value

  @builtins.property
  def spatial_scale(self):
    return _ods_ir.FloatAttr(self.operation.attributes["spatial_scale"])

  @spatial_scale.setter
  def spatial_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scale"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReciprocalOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, const_val=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if const_val is not None: attributes["const_val"] = (const_val if (
        issubclass(type(const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["const_val"])

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, keepdims, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ReduceModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def keepdims(self):
    return _ods_ir.BoolAttr(self.operation.attributes["keepdims"])

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Repeate"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, repeats, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(repeats))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def repeats(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, shape=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if shape is not None: attributes["shape"] = (shape if (
        issubclass(type(shape), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RetinaFaceDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RetinaFaceDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, nms_threshold, confidence_threshold, keep_topk, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["confidence_threshold"] = (confidence_threshold if (
    issubclass(type(confidence_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(confidence_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def nms_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["nms_threshold"])

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def confidence_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["confidence_threshold"])

  @confidence_threshold.setter
  def confidence_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["confidence_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["keep_topk"])

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RoiAlign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, rois, mode, output_height, output_width, sampling_ratio, spatial_scale, align_corners, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(rois))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RoiAlignModeAttr')) else
      _ods_ir.AttrBuilder.get('RoiAlignModeAttr')(mode, context=_ods_context))
    attributes["output_height"] = (output_height if (
    issubclass(type(output_height), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_height, context=_ods_context))
    attributes["output_width"] = (output_width if (
    issubclass(type(output_width), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_width, context=_ods_context))
    attributes["sampling_ratio"] = (sampling_ratio if (
    issubclass(type(sampling_ratio), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(sampling_ratio, context=_ods_context))
    attributes["spatial_scale"] = (spatial_scale if (
    issubclass(type(spatial_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(spatial_scale, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rois(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return _ods_ir.StringAttr(self.operation.attributes["mode"])

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output_height(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["output_height"])

  @output_height.setter
  def output_height(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_height"] = value

  @builtins.property
  def output_width(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["output_width"])

  @output_width.setter
  def output_width(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_width"] = value

  @builtins.property
  def sampling_ratio(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["sampling_ratio"])

  @sampling_ratio.setter
  def sampling_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sampling_ratio"] = value

  @builtins.property
  def spatial_scale(self):
    return _ods_ir.FloatAttr(self.operation.attributes["spatial_scale"])

  @spatial_scale.setter
  def spatial_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scale"] = value

  @builtins.property
  def align_corners(self):
    return _ods_ir.BoolAttr(self.operation.attributes["align_corners"])

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleLutOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScaleLut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, bias, *, sign=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["bias"] = (bias if (
    issubclass(type(bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(bias, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def sign(self):
    return _ods_ir.BoolAttr(self.operation.attributes["sign"])

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Scale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, bias, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScatterElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScatterElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, updates, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScatterNDOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScatterND"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input_data, indices, updates, *, reduction=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input_data))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    if reduction is not None: attributes["reduction"] = (reduction if (
        issubclass(type(reduction), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(reduction, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input_data(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def reduction(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["reduction"])

  @reduction.setter
  def reduction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShuffleChannelOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ShuffleChannel"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, group, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["group"] = (group if (
    issubclass(type(group), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def group(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["group"])

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SiLUOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SiLU"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, scale=None, bias=None, log=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if bias is not None: attributes["bias"] = (bias if (
        issubclass(type(bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(bias, context=_ods_context))
    if log is not None: attributes["log"] = (log if (
        issubclass(type(log), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(log, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return _ods_ir.FloatAttr(self.operation.attributes["scale"])

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def bias(self):
    return _ods_ir.FloatAttr(self.operation.attributes["bias"])

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def log(self):
    return _ods_ir.BoolAttr(self.operation.attributes["log"])

  @log.setter
  def log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["log"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SinOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SinhOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SizeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Size"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SliceAxisOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SliceAxis"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, start, step, end, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(axis))
    operands.append(_get_op_result_or_value(start))
    operands.append(_get_op_result_or_value(step))
    operands.append(_get_op_result_or_value(end))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def end(self):
    return self.operation.operands[4]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offsetT, endsT, stepsT, offset, steps, ends, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(offsetT))
    operands.append(_get_op_result_or_value(endsT))
    operands.append(_get_op_result_or_value(stepsT))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    attributes["steps"] = (steps if (
    issubclass(type(steps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(steps, context=_ods_context))
    attributes["ends"] = (ends if (
    issubclass(type(ends), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(ends, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offsetT(self):
    return self.operation.operands[1]

  @builtins.property
  def endsT(self):
    return self.operation.operands[2]

  @builtins.property
  def stepsT(self):
    return self.operation.operands[3]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, log=None, beta=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if log is not None: attributes["log"] = (log if (
        issubclass(type(log), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(log, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def log(self):
    return _ods_ir.BoolAttr(self.operation.attributes["log"])

  @log.setter
  def log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["log"] = value

  @builtins.property
  def beta(self):
    return _ods_ir.FloatAttr(self.operation.attributes["beta"])

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftplusOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Softplus"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftsignOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Softsign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Split"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, input, axis, num, *, split_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["num"] = (num if (
    issubclass(type(num), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num, context=_ods_context))
    if split_size is not None: attributes["split_size"] = (split_size if (
        issubclass(type(split_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(split_size, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def num(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num"])

  @num.setter
  def num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Squeeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class StridedSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.StridedSlice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, starts, ends, strides, begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(starts))
    operands.append(_get_op_result_or_value(ends))
    operands.append(_get_op_result_or_value(strides))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["begin_mask"] = (begin_mask if (
    issubclass(type(begin_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(begin_mask, context=_ods_context))
    attributes["end_mask"] = (end_mask if (
    issubclass(type(end_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(end_mask, context=_ods_context))
    attributes["ellipsis_mask"] = (ellipsis_mask if (
    issubclass(type(ellipsis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ellipsis_mask, context=_ods_context))
    attributes["new_axis_mask"] = (new_axis_mask if (
    issubclass(type(new_axis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(new_axis_mask, context=_ods_context))
    attributes["shrink_axis_mask"] = (shrink_axis_mask if (
    issubclass(type(shrink_axis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(shrink_axis_mask, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def starts(self):
    return self.operation.operands[1]

  @builtins.property
  def ends(self):
    return self.operation.operands[2]

  @builtins.property
  def strides(self):
    return self.operation.operands[3]

  @builtins.property
  def begin_mask(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["begin_mask"])

  @begin_mask.setter
  def begin_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin_mask"] = value

  @builtins.property
  def end_mask(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["end_mask"])

  @end_mask.setter
  def end_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end_mask"] = value

  @builtins.property
  def ellipsis_mask(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["ellipsis_mask"])

  @ellipsis_mask.setter
  def ellipsis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ellipsis_mask"] = value

  @builtins.property
  def new_axis_mask(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["new_axis_mask"])

  @new_axis_mask.setter
  def new_axis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["new_axis_mask"] = value

  @builtins.property
  def shrink_axis_mask(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["shrink_axis_mask"])

  @shrink_axis_mask.setter
  def shrink_axis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shrink_axis_mask"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SubConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SubConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, is_reverse=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["const_val"])

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def is_reverse(self):
    return _ods_ir.BoolAttr(self.operation.attributes["is_reverse"])

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, is_reverse=None, do_relu=None, relu_limit=None, coeff=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return _ods_ir.BoolAttr(self.operation.attributes["is_reverse"])

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwapChannelOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SwapChannel"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, channel_order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(channel_order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwapDimInnerOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SwapDimInner"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TanOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, tile, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["tile"] = (tile if (
    issubclass(type(tile), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(tile, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def tile(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["tile"])

  @tile.setter
  def tile(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TopKOp(_ods_ir.OpView):
  OPERATION_NAME = "top.TopK"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, axis, K, *, largest=None, sorted=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    attributes["K"] = (K if (
    issubclass(type(K), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(K, context=_ods_context))
    if largest is not None: attributes["largest"] = (largest if (
        issubclass(type(largest), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(largest, context=_ods_context))
    if sorted is not None: attributes["sorted"] = (sorted if (
        issubclass(type(sorted), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sorted, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def K(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["K"])

  @K.setter
  def K(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["K"] = value

  @builtins.property
  def largest(self):
    return _ods_ir.BoolAttr(self.operation.attributes["largest"])

  @largest.setter
  def largest(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["largest"] = value

  @builtins.property
  def sorted(self):
    return _ods_ir.BoolAttr(self.operation.attributes["sorted"])

  @sorted.setter
  def sorted(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sorted"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim0, dim1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim0"] = (dim0 if (
    issubclass(type(dim0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(dim0, context=_ods_context))
    attributes["dim1"] = (dim1 if (
    issubclass(type(dim1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(dim1, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim0(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dim0"])

  @dim0.setter
  def dim0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim0"] = value

  @builtins.property
  def dim1(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dim1"])

  @dim1.setter
  def dim1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim1"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TupleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.UnTuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnpackOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["axis"])

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnsqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Unsqueeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UpsampleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Upsample"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale_h, scale_w, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_w, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["scale_h"])

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["scale_w"])

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def do_relu(self):
    return _ods_ir.BoolAttr(self.operation.attributes["do_relu"])

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return _ods_ir.FloatAttr(self.operation.attributes["relu_limit"])

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ViewOp(_ods_ir.OpView):
  OPERATION_NAME = "top.View"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WeightOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Weight"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, *, scale=None, do_compress=None, store_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    if do_compress is not None: attributes["do_compress"] = (do_compress if (
        issubclass(type(do_compress), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_compress, context=_ods_context))
    if store_mode is not None: attributes["store_mode"] = (store_mode if (
        issubclass(type(store_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StoreModeAttr')) else
          _ods_ir.AttrBuilder.get('StoreModeAttr')(store_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def do_compress(self):
    if "do_compress" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["do_compress"])

  @do_compress.setter
  def do_compress(self, value):
    if value is not None:
      self.operation.attributes["do_compress"] = value
    elif "do_compress" in self.operation.attributes:
      del self.operation.attributes["do_compress"]

  @do_compress.deleter
  def do_compress(self):
    del self.operation.attributes["do_compress"]

  @builtins.property
  def store_mode(self):
    if "store_mode" not in self.operation.attributes:
      return None
    return _ods_ir.StringAttr(self.operation.attributes["store_mode"])

  @store_mode.setter
  def store_mode(self, value):
    if value is not None:
      self.operation.attributes["store_mode"] = value
    elif "store_mode" in self.operation.attributes:
      del self.operation.attributes["store_mode"]

  @store_mode.deleter
  def store_mode(self):
    del self.operation.attributes["store_mode"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WhereOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Where"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cond, tbrn, fbrn, *, x_is_const=None, y_is_const=None, x_const_val=None, y_const_val=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.append(_get_op_result_or_value(tbrn))
    operands.append(_get_op_result_or_value(fbrn))
    _ods_context = _ods_get_default_loc_context(loc)
    if x_is_const is not None: attributes["x_is_const"] = (x_is_const if (
        issubclass(type(x_is_const), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(x_is_const, context=_ods_context))
    if y_is_const is not None: attributes["y_is_const"] = (y_is_const if (
        issubclass(type(y_is_const), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(y_is_const, context=_ods_context))
    if x_const_val is not None: attributes["x_const_val"] = (x_const_val if (
        issubclass(type(x_const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(x_const_val, context=_ods_context))
    if y_const_val is not None: attributes["y_const_val"] = (y_const_val if (
        issubclass(type(y_const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(y_const_val, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def tbrn(self):
    return self.operation.operands[1]

  @builtins.property
  def fbrn(self):
    return self.operation.operands[2]

  @builtins.property
  def x_is_const(self):
    return _ods_ir.BoolAttr(self.operation.attributes["x_is_const"])

  @x_is_const.setter
  def x_is_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_is_const"] = value

  @builtins.property
  def y_is_const(self):
    return _ods_ir.BoolAttr(self.operation.attributes["y_is_const"])

  @y_is_const.setter
  def y_is_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_is_const"] = value

  @builtins.property
  def x_const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["x_const_val"])

  @x_const_val.setter
  def x_const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_const_val"] = value

  @builtins.property
  def y_const_val(self):
    return _ods_ir.FloatAttr(self.operation.attributes["y_const_val"])

  @y_const_val.setter
  def y_const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class YoloDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.YoloDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, net_input_h, net_input_w, nms_threshold, obj_threshold, keep_topk, anchors, *, spp_net=None, tiny=None, yolo_v4=None, class_num=None, flag=None, num_boxes=None, mask_group_size=None, scale=None, mask=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["net_input_h"] = (net_input_h if (
    issubclass(type(net_input_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_h, context=_ods_context))
    attributes["net_input_w"] = (net_input_w if (
    issubclass(type(net_input_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_w, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["obj_threshold"] = (obj_threshold if (
    issubclass(type(obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(obj_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    if spp_net is not None: attributes["spp_net"] = (spp_net if (
        issubclass(type(spp_net), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(spp_net, context=_ods_context))
    if tiny is not None: attributes["tiny"] = (tiny if (
        issubclass(type(tiny), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(tiny, context=_ods_context))
    if yolo_v4 is not None: attributes["yolo_v4"] = (yolo_v4 if (
        issubclass(type(yolo_v4), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(yolo_v4, context=_ods_context))
    if class_num is not None: attributes["class_num"] = (class_num if (
        issubclass(type(class_num), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(class_num, context=_ods_context))
    attributes["anchors"] = (anchors if (
    issubclass(type(anchors), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(anchors, context=_ods_context))
    if flag is not None: attributes["flag"] = (flag if (
        issubclass(type(flag), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(flag, context=_ods_context))
    if num_boxes is not None: attributes["num_boxes"] = (num_boxes if (
        issubclass(type(num_boxes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(num_boxes, context=_ods_context))
    if mask_group_size is not None: attributes["mask_group_size"] = (mask_group_size if (
        issubclass(type(mask_group_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(mask_group_size, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(scale, context=_ods_context))
    if mask is not None: attributes["mask"] = (mask if (
        issubclass(type(mask), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(mask, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def net_input_h(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["net_input_h"])

  @net_input_h.setter
  def net_input_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_h"] = value

  @builtins.property
  def net_input_w(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["net_input_w"])

  @net_input_w.setter
  def net_input_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_w"] = value

  @builtins.property
  def nms_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["nms_threshold"])

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def obj_threshold(self):
    return _ods_ir.FloatAttr(self.operation.attributes["obj_threshold"])

  @obj_threshold.setter
  def obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["obj_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["keep_topk"])

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def spp_net(self):
    return _ods_ir.BoolAttr(self.operation.attributes["spp_net"])

  @spp_net.setter
  def spp_net(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spp_net"] = value

  @builtins.property
  def tiny(self):
    return _ods_ir.BoolAttr(self.operation.attributes["tiny"])

  @tiny.setter
  def tiny(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tiny"] = value

  @builtins.property
  def yolo_v4(self):
    return _ods_ir.BoolAttr(self.operation.attributes["yolo_v4"])

  @yolo_v4.setter
  def yolo_v4(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["yolo_v4"] = value

  @builtins.property
  def class_num(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["class_num"])

  @class_num.setter
  def class_num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["class_num"] = value

  @builtins.property
  def anchors(self):
    return _ods_ir.StringAttr(self.operation.attributes["anchors"])

  @anchors.setter
  def anchors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchors"] = value

  @builtins.property
  def flag(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["flag"])

  @flag.setter
  def flag(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flag"] = value

  @builtins.property
  def num_boxes(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num_boxes"])

  @num_boxes.setter
  def num_boxes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_boxes"] = value

  @builtins.property
  def mask_group_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["mask_group_size"])

  @mask_group_size.setter
  def mask_group_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mask_group_size"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]
